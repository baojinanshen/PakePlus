<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¼ è¾“è®¾å¤‡ç»„ç¯æ‹“æ‰‘è‡ªåŠ¨ç”Ÿæˆå·¥å…·</title>
    <script src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>
    <script src="https://unpkg.com/pptxgenjs@3.10.0/dist/pptxgen.bundle.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #2c3e50);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            padding: 30px 0;
            margin-bottom: 30px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: #fff;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .developer {
            font-size: 1rem;
            background: rgba(255,255,255,0.1);
            padding: 5px 15px;
            border-radius: 20px;
            display: inline-block;
            margin-top: 10px;
        }
        
        .subtitle {
            font-size: 1.2rem;
            color: #a0d2ff;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.6;
        }
        
        .card {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .card-title {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: #4fc3f7;
            display: flex;
            align-items: center;
        }
        
        .upload-area {
            border: 2px dashed rgba(255,255,255,0.3);
            border-radius: 10px;
            padding: 40px 20px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            background: rgba(0,0,0,0.1);
        }
        
        .upload-area:hover {
            border-color: #4fc3f7;
            background: rgba(79, 195, 247, 0.05);
        }
        
        .upload-icon {
            font-size: 4rem;
            color: #4fc3f7;
            margin-bottom: 20px;
        }
        
        .upload-text {
            font-size: 1.2rem;
            margin-bottom: 15px;
        }
        
        .upload-hint {
            color: #aaa;
            font-size: 0.95rem;
        }
        
        .btn {
            background: linear-gradient(to right, #2196f3, #21cbf3);
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1.1rem;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(33, 150, 243, 0.4);
        }
        
        .btn i {
            margin-right: 8px;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(33, 150, 243, 0.6);
        }
        
        .btn:active {
            transform: translateY(1px);
        }
        
        .btn:disabled {
            background: linear-gradient(to right, #616161, #9e9e9e);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .btn-generate {
            background: linear-gradient(to right, #4CAF50, #8BC34A);
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 1.2rem;
        }
        
        .btn-generate:hover {
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.6);
        }
        
        .input-group {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .preview-section {
            display: flex;
            flex-direction: column;
            gap: 30px;
            margin-top: 30px;
        }
        
        .preview-box {
            width: 100%;
        }
        
        .preview-title {
            font-size: 1.3rem;
            margin-bottom: 15px;
            color: #ff9800;
        }
        
        .table-container {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            overflow: auto;
            max-height: 300px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            background: rgba(30, 30, 40, 0.7);
        }
        
        th {
            background: rgba(33, 150, 243, 0.3);
            padding: 12px 15px;
            text-align: left;
            font-weight: 600;
            position: sticky;
            top: 0;
        }
        
        td {
            padding: 10px 15px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        
        tr:nth-child(even) {
            background: rgba(255,255,255,0.03);
        }
        
        tr:hover {
            background: rgba(79, 195, 247, 0.1);
        }
        
        .topology-preview-container {
            position: relative;
            height: 500px;
            background: rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            overflow: hidden;
            cursor: grab;
            user-select: none;
        }
        
        .topology-preview {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform-origin: 0 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .legend {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 8px;
            padding: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            font-size: 0.85rem;
            border: 1px solid rgba(255,255,255,0.1);
            max-width: 300px;
            z-index: 20;
        }
        
        .legend-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            flex: 1;
            min-width: 90px;
        }
        
        .legend-color {
            width: 30px;
            height: 4px;
            border-radius: 2px;
        }
        
        .topology-node {
            position: absolute;
            width: 60px;
            height: 60px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-weight: 600;
            font-size: 0.9rem;
            color: #000;
            z-index: 10;
            background-size: 50%;
            background-position: center top 10px;
            background-repeat: no-repeat;
            background-color: transparent;
            border: none;
            box-shadow: none;
        }
        
        .node-label {
            position: absolute;
            font-size: 0.8rem;
            font-weight: 600;
            z-index: 15;
            background: rgba(255,255,255,0.95);
            padding: 5px 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            word-wrap: break-word;
            max-width: 150px;
            text-align: center;
            line-height: 1.3;
            color: #000;
            word-break: break-word;
        }
        
        .topology-line {
            position: absolute;
            height: 4px;
            transform-origin: left center;
            z-index: 5;
        }
        
        .topology-distance {
            position: absolute;
            background: transparent;
            padding: 3px 10px;
            font-size: 0.8rem;
            transform: translate(-50%, -50%);
            color: #fff;
            z-index: 15;
            white-space: nowrap;
            font-weight: bold;
            text-shadow: 0 1px 2px rgba(0,0,0,0.8);
        }
        
        .instructions {
            margin-top: 30px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }
        
        .instructions h3 {
            color: #ff9800;
            margin-bottom: 15px;
        }
        
        .instructions ul {
            padding-left: 25px;
        }
        
        .instructions li {
            margin-bottom: 10px;
            line-height: 1.6;
        }
        
        .instructions code {
            background: rgba(255,255,255,0.1);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
        }
        
        .status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            font-weight: 500;
            display: none;
        }
        
        .status.success {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid rgba(76, 175, 80, 0.5);
            display: block;
        }
        
        .status.error {
            background: rgba(244, 67, 54, 0.2);
            border: 1px solid rgba(244, 67, 54, 0.5);
            display: block;
        }
        
        .status.loading {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid rgba(255, 193, 7, 0.5);
            display: block;
        }
        
        footer {
            text-align: center;
            margin-top: 40px;
            padding: 20px;
            color: #aaa;
            font-size: 0.9rem;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        
        .legend-image {
            width: 24px;
            height: 24px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
        }
        
        .ring-selector {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .ring-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            color: #fff;
            padding: 5px 15px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .ring-btn.active {
            background: #4fc3f7;
            color: #1a2a6c;
            border-color: #4fc3f7;
        }
        
        .icon-reload {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            color: #fff;
            padding: 5px 10px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.8rem;
            z-index: 100;
        }
        
        .icon-reload:hover {
            background: rgba(79, 195, 247, 0.3);
        }
        
        .zoom-controls {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 100;
        }
        
        .zoom-btn {
            width: 40px;
            height: 40px;
            background: rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .zoom-btn:hover {
            background: rgba(79, 195, 247, 0.8);
        }
        
        .zoom-reset {
            background: rgba(76, 175, 80, 0.6);
        }
        
        .zoom-reset:hover {
            background: rgba(76, 175, 80, 0.8);
        }
        
        @media (max-width: 768px) {
            .input-group {
                flex-direction: column;
            }
            
            .legend {
                width: 90%;
                font-size: 0.75rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ä¼ è¾“è®¾å¤‡ç»„ç¯æ‹“æ‰‘è‡ªåŠ¨ç”Ÿæˆå·¥å…·</h1>
            <p class="subtitle">ä¸Šä¼ è·³çº¤è¡¨Excelæ–‡ä»¶ï¼Œè‡ªåŠ¨ç”Ÿæˆä¸“ä¸šçš„ç»„ç¯æ‹“æ‰‘PPTæ¼”ç¤ºæ–‡ç¨¿</p>
            <p class="developer">å¼€å‘è€…ï¼šå¾®ä¿¡å…¬ä¼—å·ï¼šè½¯ä»¶å¸®Pro</p>
        </header>
        
        <main>
            <div class="card">
                <h2 class="card-title">ä¸Šä¼ è·³çº¤è¡¨</h2>
                <div class="upload-area" id="dropArea">
                    <div class="upload-icon">ğŸ“Š</div>
                    <p class="upload-text">æ‹–æ‹½Excelæ–‡ä»¶åˆ°æ­¤å¤„æˆ–ç‚¹å‡»ä¸Šä¼ </p>
                    <p class="upload-hint">æ”¯æŒ .xlsx æˆ– .xls æ ¼å¼çš„è·³çº¤è¡¨æ–‡ä»¶</p>
                    <input type="file" id="fileInput" accept=".xlsx, .xls">
                </div>
                
                <div class="input-group">
                    <button class="btn" id="sampleBtn">
                        <i>ğŸ“¥</i> ä¸‹è½½ç¤ºä¾‹æ–‡ä»¶
                    </button>
                    <button class="btn" id="generateBtn" disabled>
                        <i>âš¡</i> ç”Ÿæˆæ‹“æ‰‘PPT
                    </button>
                </div>
                
                <div id="statusMessage" class="status"></div>
            </div>
            
            <div class="preview-section">
                <div class="preview-box">
                    <h3 class="preview-title">è¡¨æ ¼æ•°æ®é¢„è§ˆ</h3>
                    <div class="table-container">
                        <table id="dataTable">
                            <thead>
                                <tr>
                                    <th>åºå·</th>
                                    <th>æ¥å…¥ç¯</th>
                                    <th>èµ·ç‚¹</th>
                                    <th>ç»ˆç‚¹</th>
                                    <th>å…‰ç¼†å±æ€§</th>
                                    <th>å…‰ç¼†è·ç¦»</th>
                                    <th>æ–°å¢è®¾å¤‡</th>
                                    <th>åŸæœ‰è®¾å¤‡</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td colspan="8" style="text-align: center; color: #aaa;">
                                        ä¸Šä¼ Excelæ–‡ä»¶åæ˜¾ç¤ºæ•°æ®é¢„è§ˆ
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
                
                <div class="preview-box">
                    <h3 class="preview-title">æ‹“æ‰‘å›¾é¢„è§ˆ</h3>
                    <div class="ring-selector" id="ringSelector" style="display:none;">
                        <!-- ç¯é€‰æ‹©æŒ‰é’®å°†åŠ¨æ€ç”Ÿæˆ -->
                    </div>
                    <div class="topology-preview-container" id="topologyContainer">
                        <div class="topology-preview" id="topologyPreview">
                            <div style="color: #aaa; text-align: center; padding-top: 50px;">
                                æ‹“æ‰‘å›¾å°†åœ¨ç”Ÿæˆåæ˜¾ç¤ºåœ¨æ­¤å¤„<br>
                                <small>ä¼˜åŒ–æ ‡ç­¾ä½ç½®ï¼Œä¸PPTæ•ˆæœä¸€è‡´</small>
                            </div>
                        </div>
                        
                        <!-- å›¾ä¾‹ - å›ºå®šä½ç½® -->
                        <div class="legend">
                            <div class="legend-item">
                                <div class="legend-image" style="background-image: url('icons/server.png');"></div>
                                <span>æœºæˆ¿</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-image" style="background-image: url('icons/network-device.png');"></div>
                                <span>åŸæœ‰è®¾å¤‡</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-image" style="background-image: url('icons/new-device.png');"></div>
                                <span>æ–°å¢è®¾å¤‡</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-image" style="background-image: url('icons/fiber-point.png');"></div>
                                <span>è·³çº¤ç‚¹</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #4CAF50;"></div>
                                <span>åŸæœ‰å…‰ç¼†</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #F44336;"></div>
                                <span>æ–°å»ºå…‰ç¼†</span>
                            </div>
                        </div>
                        
                        <!-- ç¼©æ”¾æ§åˆ¶ -->
                        <div class="zoom-controls">
                            <button class="zoom-btn" id="zoomInBtn">+</button>
                            <button class="zoom-btn" id="zoomOutBtn">-</button>
                            <button class="zoom-btn zoom-reset" id="resetViewBtn">â†º</button>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="instructions">
                <h3>ä½¿ç”¨è¯´æ˜</h3>
                <ul>
                    <li>ä¸Šä¼ çš„Excelæ–‡ä»¶å¿…é¡»åŒ…å«ä»¥ä¸‹åˆ—ï¼š<code>åºå·</code>, <code>æ¥å…¥ç¯</code>, <code>èµ·ç‚¹</code>, <code>ç»ˆç‚¹</code>, <code>å…‰ç¼†å±æ€§</code>, <code>å…‰ç¼†è·ç¦»</code>, <code>æ–°å¢è®¾å¤‡ç«™ç‚¹</code>, <code>åŸæœ‰è®¾å¤‡ç«™ç‚¹</code></li>
                    <li>ç³»ç»Ÿä¼šè‡ªåŠ¨è¯†åˆ«å¤šä¸ªç»„ç¯æ–¹æ¡ˆï¼ˆæ¯ä¸ªæ–¹æ¡ˆä¹‹é—´ç”¨ç©ºè¡Œåˆ†éš”ï¼‰</li>
                    <li>ç”Ÿæˆçš„PPTæ–‡ä»¶å°†åŒ…å«å¤šä¸ªé¡µé¢ï¼Œæ¯ä¸ªç»„ç¯æ–¹æ¡ˆä¸€ä¸ªé¡µé¢</li>
                    <li>æ¯ä¸ªé¡µé¢å·¦ä¸‹è§’ä¼šè‡ªåŠ¨æ·»åŠ å›¾ä¾‹è¯´æ˜</li>
                        </ul>
                    </li>
                </ul>
            </div>
        </main>
        
        <footer>
            <p>ä¼ è¾“è®¾å¤‡ç»„ç¯æ‹“æ‰‘è‡ªåŠ¨ç”Ÿæˆå·¥å…· v1.0 | å¾®ä¿¡å…¬ä¼—å·ï¼šè½¯ä»¶å¸®Pro</p>
            <p>Â© 2025 ç½‘ç»œæ‹“æ‰‘è‡ªåŠ¨åŒ–å·¥å…· | æ•°æ®å®‰å…¨å¯é </p>
        </footer>
    </div>

    <script>
        // é¡µé¢å…ƒç´ 
        const fileInput = document.getElementById('fileInput');
        const dropArea = document.getElementById('dropArea');
        const generateBtn = document.getElementById('generateBtn');
        const dataTable = document.getElementById('dataTable');
        const topologyPreview = document.getElementById('topologyPreview');
        const sampleBtn = document.getElementById('sampleBtn');
        const statusMessage = document.getElementById('statusMessage');
        const ringSelector = document.getElementById('ringSelector');
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const resetViewBtn = document.getElementById('resetViewBtn');
        const topologyContainer = document.getElementById('topologyContainer');
        
        // å½“å‰è§£æçš„æ•°æ®
        let ringData = [];
        let currentRingIndex = 0;
        
        // å›¾æ ‡URLæ˜ å°„ - ä½¿ç”¨æœ¬åœ°è·¯å¾„
        const iconUrls = {
            'æœºæˆ¿': 'icons/server.png',
            'åŸæœ‰è®¾å¤‡': 'icons/network-device.png',
            'æ–°å¢è®¾å¤‡': 'icons/new-device.png',
            'è·³çº¤ç‚¹': 'icons/fiber-point.png'
        };
        
        // å­˜å‚¨æ‰€æœ‰å›¾æ ‡çš„Base64æ•°æ®
        const iconBase64Data = {
            'æœºæˆ¿': null,
            'åŸæœ‰è®¾å¤‡': null,
            'æ–°å¢è®¾å¤‡': null,
            'è·³çº¤ç‚¹': null
        };
        
        // è§†å›¾çŠ¶æ€
        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let startX, startY;
        
        // åˆå§‹åŒ–æ—¶åŠ è½½æ‰€æœ‰å›¾æ ‡
        loadAllIcons();
        
        // è®¾ç½®è§†å›¾å˜æ¢
        function setViewTransform() {
            topologyPreview.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
        }
        
        // åˆå§‹åŒ–è§†å›¾æ§åˆ¶
        function initViewControls() {
            zoomInBtn.addEventListener('click', () => {
                scale = Math.min(scale * 1.2, 3);
                setViewTransform();
            });
            
            zoomOutBtn.addEventListener('click', () => {
                scale = Math.max(scale * 0.8, 0.5);
                setViewTransform();
            });
            
            resetViewBtn.addEventListener('click', () => {
                scale = 1;
                offsetX = 0;
                offsetY = 0;
                setViewTransform();
            });
            
            // æ‹–æ‹½å¹³ç§»
            topologyContainer.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('zoom-btn') || 
                    e.target.closest('.legend')) return;
                
                isDragging = true;
                startX = e.clientX - offsetX;
                startY = e.clientY - offsetY;
                topologyContainer.style.cursor = 'grabbing';
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                offsetX = e.clientX - startX;
                offsetY = e.clientY - startY;
                setViewTransform();
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
                topologyContainer.style.cursor = 'grab';
            });
            
            // è§¦æ‘¸äº‹ä»¶æ”¯æŒ
            topologyContainer.addEventListener('touchstart', (e) => {
                if (e.touches.length !== 1) return;
                e.preventDefault();
                
                isDragging = true;
                startX = e.touches[0].clientX - offsetX;
                startY = e.touches[0].clientY - offsetY;
                topologyContainer.style.cursor = 'grabbing';
            });
            
            document.addEventListener('touchmove', (e) => {
                if (!isDragging || e.touches.length !== 1) return;
                e.preventDefault();
                
                offsetX = e.touches[0].clientX - startX;
                offsetY = e.touches[0].clientY - startY;
                setViewTransform();
            });
            
            document.addEventListener('touchend', () => {
                isDragging = false;
                topologyContainer.style.cursor = 'grab';
            });
        }
        
        initViewControls();
        
        // å¤„ç†æ–‡ä»¶æ‹–æ”¾
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, preventDefaults, false);
        });
        
        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }
        
        ['dragenter', 'dragover'].forEach(eventName => {
            dropArea.addEventListener(eventName, highlight, false);
        });
        
        ['dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, unhighlight, false);
        });
        
        function highlight() {
            dropArea.style.borderColor = '#4fc3f7';
            dropArea.style.backgroundColor = 'rgba(79, 195, 247, 0.1)';
        }
        
        function unhighlight() {
            dropArea.style.borderColor = 'rgba(255,255,255,0.3)';
            dropArea.style.backgroundColor = 'rgba(0,0,0,0.1)';
        }
        
        // å¤„ç†æ–‡ä»¶æ‹–æ”¾
        dropArea.addEventListener('drop', handleDrop, false);
        dropArea.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', handleFileSelect);
        
        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            fileInput.files = files;
            handleFiles(files);
        }
        
        function handleFileSelect() {
            handleFiles(this.files);
        }
        
        function handleFiles(files) {
            if (files.length === 0) return;
            
            const file = files[0];
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, {type: 'array'});
                    
                    // è·å–ç¬¬ä¸€ä¸ªå·¥ä½œè¡¨
                    const firstSheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[firstSheetName];
                    
                    // è½¬æ¢ä¸ºJSON
                    const jsonData = XLSX.utils.sheet_to_json(worksheet, {header: 1});
                    
                    // è§£ææ•°æ®
                    parseData(jsonData);
                    
                    // å¯ç”¨ç”ŸæˆæŒ‰é’®
                    generateBtn.disabled = false;
                    
                    showStatus("æ–‡ä»¶è§£ææˆåŠŸï¼å‡†å¤‡ç”ŸæˆPPT", "success");
                    
                } catch (error) {
                    console.error('Error processing Excel file:', error);
                    showStatus("å¤„ç†Excelæ–‡ä»¶æ—¶å‡ºé”™: " + error.message, "error");
                }
            };
            
            reader.readAsArrayBuffer(file);
        }
        
        // åŠ è½½æ‰€æœ‰å›¾æ ‡å¹¶è½¬æ¢ä¸ºBase64
        function loadAllIcons() {
            showStatus("æ­£åœ¨åŠ è½½å›¾æ ‡èµ„æº...", "loading");
            
            const iconTypes = Object.keys(iconUrls);
            let loadedCount = 0;
            
            iconTypes.forEach(type => {
                const url = iconUrls[type];
                loadIconWithRetry(type, url, 3);
            });
        }
        
        // å¸¦é‡è¯•æœºåˆ¶çš„å›¾æ ‡åŠ è½½
        function loadIconWithRetry(type, url, retries) {
            getBase64FromImageUrl(url)
                .then(base64 => {
                    iconBase64Data[type] = base64;
                    loadedCount++;
                    
                    if (loadedCount === Object.keys(iconUrls).length) {
                        showStatus("æ‰€æœ‰å›¾æ ‡èµ„æºå·²åŠ è½½å®Œæˆ", "success");
                        setTimeout(() => {
                            statusMessage.style.display = "none";
                        }, 2000);
                    }
                })
                .catch(error => {
                    console.error(`Error loading icon ${type}:`, error);
                    if (retries > 0) {
                        showStatus(`å›¾æ ‡åŠ è½½å¤±è´¥ï¼Œæ­£åœ¨é‡è¯• (${4-retries}/3)`, "loading");
                        setTimeout(() => {
                            loadIconWithRetry(type, url, retries - 1);
                        }, 1000);
                    } else {
                        showStatus(`å›¾æ ‡ ${type} åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•`, "error");
                        createIconReloadButton();
                    }
                });
        }
        
        // åˆ›å»ºå›¾æ ‡é‡è½½æŒ‰é’®
        function createIconReloadButton() {
            const reloadBtn = document.createElement('button');
            reloadBtn.className = 'icon-reload';
            reloadBtn.textContent = 'é‡æ–°åŠ è½½å›¾æ ‡';
            reloadBtn.onclick = () => {
                reloadBtn.remove();
                loadAllIcons();
            };
            document.body.appendChild(reloadBtn);
        }
        
        // ä»URLè·å–å›¾ç‰‡çš„Base64ç¼–ç 
        function getBase64FromImageUrl(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.height = img.naturalHeight;
                    canvas.width = img.naturalWidth;
                    ctx.drawImage(img, 0, 0);
                    const dataURL = canvas.toDataURL('image/png');
                    resolve(dataURL);
                };
                img.onerror = (e) => {
                    console.error('Image load error:', e);
                    reject(new Error('Failed to load image: ' + url));
                };
                img.src = url;
            });
        }
        
        // è§£æExcelæ•°æ®
        function parseData(jsonData) {
            ringData = [];
            
            // æŸ¥æ‰¾æ ‡é¢˜è¡Œ
            let headerRowIndex = -1;
            for (let i = 0; i < jsonData.length; i++) {
                if (jsonData[i].length > 0 && 
                    (jsonData[i][0] === 'åºå·' || jsonData[i][0] === 'A')) {
                    headerRowIndex = i;
                    break;
                }
            }
            
            if (headerRowIndex === -1) {
                showStatus("æœªæ‰¾åˆ°æœ‰æ•ˆçš„æ ‡é¢˜è¡Œ", "error");
                return;
            }
            
            // æå–æ•°æ®
            let currentRing = null;
            
            for (let i = headerRowIndex + 1; i < jsonData.length; i++) {
                const row = jsonData[i];
                
                // è·³è¿‡ç©ºè¡Œ
                if (row.length === 0 || row.every(cell => cell === null || cell === '')) {
                    if (currentRing && currentRing.segments.length > 0) {
                        ringData.push(currentRing);
                    }
                    currentRing = null;
                    continue;
                }
                
                // è§£ææœ‰æ•ˆè¡Œ
                const segment = {
                    id: row[0],
                    ringName: row[1],
                    region: row[2],
                    start: row[3],
                    end: row[4],
                    cableType: row[5],
                    coreCount: row[6],
                    distance: row[7],
                    room1: row[8],
                    room2: row[9],
                    route: row[10],
                    newDevice: row[11],
                    existingDevice: row[12] // æ–°å¢åŸæœ‰è®¾å¤‡ç«™ç‚¹åˆ—
                };
                
                // æ–°ç¯å¼€å§‹
                if (segment.ringName) {
                    if (currentRing && currentRing.segments.length > 0) {
                        ringData.push(currentRing);
                    }
                    currentRing = {
                        name: segment.ringName,
                        region: segment.region,
                        room1: segment.room1,
                        room2: segment.room2,
                        segments: [segment],
                        roomNodes: [],
                        newDeviceNodes: [],
                        existingDeviceNodes: [], // æ–°å¢åŸæœ‰è®¾å¤‡èŠ‚ç‚¹æ•°ç»„
                        routeNodes: segment.route ? segment.route.split('-') : []
                    };
                    
                    // æ·»åŠ æœºæˆ¿èŠ‚ç‚¹
                    if (segment.room1 && !currentRing.roomNodes.includes(segment.room1)) {
                        currentRing.roomNodes.push(segment.room1);
                    }
                    if (segment.room2 && !currentRing.roomNodes.includes(segment.room2)) {
                        currentRing.roomNodes.push(segment.room2);
                    }
                    
                    // æ·»åŠ æ–°å¢è®¾å¤‡èŠ‚ç‚¹
                    if (segment.newDevice && !currentRing.newDeviceNodes.includes(segment.newDevice)) {
                        currentRing.newDeviceNodes.push(segment.newDevice);
                    }
                    
                    // æ·»åŠ åŸæœ‰è®¾å¤‡èŠ‚ç‚¹
                    if (segment.existingDevice && !currentRing.existingDeviceNodes.includes(segment.existingDevice)) {
                        currentRing.existingDeviceNodes.push(segment.existingDevice);
                    }
                } else if (currentRing) {
                    currentRing.segments.push(segment);
                    
                    // æ·»åŠ æœºæˆ¿èŠ‚ç‚¹
                    if (segment.room1 && !currentRing.roomNodes.includes(segment.room1)) {
                        currentRing.roomNodes.push(segment.room1);
                    }
                    if (segment.room2 && !currentRing.roomNodes.includes(segment.room2)) {
                        currentRing.roomNodes.push(segment.room2);
                    }
                    
                    // æ·»åŠ æ–°å¢è®¾å¤‡èŠ‚ç‚¹
                    if (segment.newDevice && !currentRing.newDeviceNodes.includes(segment.newDevice)) {
                        currentRing.newDeviceNodes.push(segment.newDevice);
                    }
                    
                    // æ·»åŠ åŸæœ‰è®¾å¤‡èŠ‚ç‚¹
                    if (segment.existingDevice && !currentRing.existingDeviceNodes.includes(segment.existingDevice)) {
                        currentRing.existingDeviceNodes.push(segment.existingDevice);
                    }
                }
            }
            
            // æ·»åŠ æœ€åä¸€ä¸ªç¯
            if (currentRing && currentRing.segments.length > 0) {
                ringData.push(currentRing);
            }
            
            // æ›´æ–°è¡¨æ ¼é¢„è§ˆ
            updateTablePreview();
            
            // ç”Ÿæˆç¯é€‰æ‹©å™¨
            createRingSelector();
            
            // ç”Ÿæˆæ‹“æ‰‘é¢„è§ˆ
            generateTopologyPreview();
        }
        
        // åˆ›å»ºç¯é€‰æ‹©å™¨
        function createRingSelector() {
            ringSelector.innerHTML = '';
            ringSelector.style.display = 'flex';
            
            ringData.forEach((ring, index) => {
                const btn = document.createElement('button');
                btn.className = 'ring-btn';
                if (index === currentRingIndex) {
                    btn.classList.add('active');
                }
                btn.textContent = ring.name || `ç»„ç¯æ–¹æ¡ˆ ${index + 1}`;
                btn.onclick = () => {
                    currentRingIndex = index;
                    generateTopologyPreview();
                    // æ›´æ–°æŒ‰é’®çŠ¶æ€
                    document.querySelectorAll('.ring-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                };
                ringSelector.appendChild(btn);
            });
        }
        
        // æ›´æ–°è¡¨æ ¼é¢„è§ˆ
        function updateTablePreview() {
            const tbody = dataTable.querySelector('tbody');
            tbody.innerHTML = '';
            
            if (ringData.length === 0) {
                const row = document.createElement('tr');
                row.innerHTML = `<td colspan="8" style="text-align: center; color: #aaa;">æœªæ‰¾åˆ°æœ‰æ•ˆæ•°æ®</td>`;
                tbody.appendChild(row);
                return;
            }
            
            ringData.forEach(ring => {
                ring.segments.forEach(segment => {
                    const row = document.createElement('tr');
                    
                    row.innerHTML = `
                        <td>${segment.id || ''}</td>
                        <td>${segment.ringName || ring.name || ''}</td>
                        <td>${segment.start || ''}</td>
                        <td>${segment.end || ''}</td>
                        <td>${segment.cableType || ''}</td>
                        <td>${segment.distance || ''}</td>
                        <td>${segment.newDevice || ''}</td>
                        <td>${segment.existingDevice || ''}</td>
                    `;
                    
                    tbody.appendChild(row);
                });
                
                // æ·»åŠ åˆ†éš”è¡Œ
                const separator = document.createElement('tr');
                separator.innerHTML = `<td colspan="8" style="background: rgba(255,255,255,0.05); height: 3px;"></td>`;
                tbody.appendChild(separator);
            });
        }
        
        // ç¡®å®šèŠ‚ç‚¹ç±»å‹
        function getNodeType(nodeName, ring) {
            // æ£€æŸ¥æ˜¯å¦æ˜¯æœºæˆ¿
            if (ring.roomNodes.includes(nodeName)) {
                return 'æœºæˆ¿';
            }
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯æ–°å¢è®¾å¤‡
            if (ring.newDeviceNodes.includes(nodeName)) {
                return 'æ–°å¢è®¾å¤‡';
            }
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯åŸæœ‰è®¾å¤‡
            if (ring.existingDeviceNodes.includes(nodeName)) {
                return 'åŸæœ‰è®¾å¤‡';
            }
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯è·³çº¤ç‚¹
            let isFiberPoint = true;
            
            // æ£€æŸ¥æ˜¯å¦åœ¨ç‰¹æ®Šåˆ—ä¸­å‡ºç°
            ring.segments.forEach(segment => {
                if (segment.room1 === nodeName || segment.room2 === nodeName || 
                    segment.newDevice === nodeName || segment.existingDevice === nodeName) {
                    isFiberPoint = false;
                }
            });
            
            if (isFiberPoint) {
                return 'è·³çº¤ç‚¹';
            }
            
            // é»˜è®¤åŸæœ‰è®¾å¤‡
            return 'åŸæœ‰è®¾å¤‡';
        }
        
        // ç”Ÿæˆæ‹“æ‰‘é¢„è§ˆï¼ˆä¼˜åŒ–æ ‡ç­¾ä½ç½®ï¼‰
        function generateTopologyPreview() {
            if (ringData.length === 0) {
                topologyPreview.innerHTML = `
                    <div style="color: #aaa; text-align: center; padding-top: 50px;">
                        æ‹“æ‰‘å›¾å°†åœ¨ç”Ÿæˆåæ˜¾ç¤ºåœ¨æ­¤å¤„
                    </div>
                `;
                return;
            }
            
            // ä½¿ç”¨å½“å‰é€‰æ‹©çš„ç¯ç”Ÿæˆé¢„è§ˆ
            const ring = ringData[currentRingIndex];
            topologyPreview.innerHTML = '';
            
            // åˆ›å»ºèŠ‚ç‚¹å’Œçº¿è·¯
            const nodes = {};
            const lines = [];
            
            // æ”¶é›†æ‰€æœ‰èŠ‚ç‚¹
            ring.segments.forEach(segment => {
                if (segment.start) {
                    nodes[segment.start] = {
                        id: segment.start,
                        type: getNodeType(segment.start, ring),
                        distance: segment.distance
                    };
                }
                
                if (segment.end) {
                    nodes[segment.end] = {
                        id: segment.end,
                        type: getNodeType(segment.end, ring),
                        distance: segment.distance
                    };
                }
                
                // æ·»åŠ çº¿è·¯
                if (segment.start && segment.end) {
                    lines.push({
                        start: segment.start,
                        end: segment.end,
                        type: segment.cableType,
                        distance: segment.distance
                    });
                }
            });
            
            // ä½¿ç”¨è·¯ç”±é¡ºåºæ’åˆ—èŠ‚ç‚¹
            const routeNodes = ring.routeNodes || Object.keys(nodes);
            const containerWidth = topologyPreview.offsetWidth;
            const containerHeight = topologyPreview.offsetHeight;
            
            // è®¡ç®—èŠ‚ç‚¹ä½ç½®ï¼ˆå‡µå½¢å¸ƒå±€ - å¼€å£å‘ä¸‹ï¼‰
            const nodePositions = {};
            const uLayout = calculateUShapeLayout(routeNodes, containerWidth, containerHeight);
            
            routeNodes.forEach((nodeId, index) => {
                nodePositions[nodeId] = uLayout.positions[index];
            });
            
            // ç»˜åˆ¶çº¿è·¯ - æŒ‰ç…§è·¯ç”±é¡ºåº
            for (let i = 0; i < routeNodes.length - 1; i++) {
                const startNode = routeNodes[i];
                const endNode = routeNodes[i+1];
                
                if (!nodePositions[startNode] || !nodePositions[endNode]) continue;
                
                const x1 = nodePositions[startNode].x;
                const y1 = nodePositions[startNode].y;
                const x2 = nodePositions[endNode].x;
                const y2 = nodePositions[endNode].y;
                
                // è®¡ç®—çº¿è·¯é•¿åº¦å’Œè§’åº¦
                const dx = x2 - x1;
                const dy = y2 - y1;
                const length = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                
                // åˆ›å»ºçº¿è·¯å…ƒç´ 
                const lineElement = document.createElement('div');
                lineElement.className = 'topology-line';
                lineElement.style.width = `${length}px`;
                lineElement.style.left = `${x1}px`;
                lineElement.style.top = `${y1}px`;
                lineElement.style.transform = `rotate(${angle}deg)`;
                
                // è®¾ç½®çº¿è·¯é¢œè‰²å’Œå®½åº¦
                const lineType = getLineType(ring, startNode, endNode);
                if (lineType === 'æ–°å»º') {
                    lineElement.style.backgroundColor = '#F44336'; // æ–°å»ºå…‰ç¼† - çº¢è‰²
                    lineElement.style.height = '5px';
                    lineElement.style.zIndex = '6'; // æ–°å»ºçº¿è·¯åœ¨ä¸Šå±‚
                } else {
                    lineElement.style.backgroundColor = '#4CAF50'; // åŸæœ‰å…‰ç¼† - ç»¿è‰²
                    lineElement.style.height = '3px';
                }
                
                topologyPreview.appendChild(lineElement);
                
                // æ·»åŠ è·ç¦»æ ‡ç­¾ï¼ˆç¡®ä¿è·ç¦»å­˜åœ¨ï¼‰
                const distance = getLineDistance(ring, startNode, endNode);
                if (distance) {
                    const distanceLabel = document.createElement('div');
                    distanceLabel.className = 'topology-distance';
                    distanceLabel.textContent = distance;
                    
                    // è·ç¦»æ ‡ç­¾æ”¾åœ¨çº¿æ®µä¸­å¿ƒç‚¹
                    distanceLabel.style.left = `${(x1 + x2) / 2}px`;
                    distanceLabel.style.top = `${(y1 + y2) / 2}px`;
                    
                    topologyPreview.appendChild(distanceLabel);
                }
            }
            
            // ç»˜åˆ¶èŠ‚ç‚¹
            routeNodes.forEach((nodeId, index) => {
                if (!nodePositions[nodeId]) return;
                
                const x = nodePositions[nodeId].x;
                const y = nodePositions[nodeId].y;
                const node = nodes[nodeId] || {
                    id: nodeId,
                    type: getNodeType(nodeId, ring)
                };
                
                // åˆ›å»ºèŠ‚ç‚¹å›¾æ ‡
                const nodeElement = document.createElement('div');
                nodeElement.className = 'topology-node';
                nodeElement.style.left = `${x - 30}px`; // è°ƒæ•´ä¸ºä¸­å¿ƒç‚¹
                nodeElement.style.top = `${y - 30}px`;  // è°ƒæ•´ä¸ºä¸­å¿ƒç‚¹
                
                // è®¾ç½®èŠ‚ç‚¹èƒŒæ™¯å›¾ç‰‡
                const iconUrl = iconUrls[node.type] || iconUrls['åŸæœ‰è®¾å¤‡'];
                nodeElement.style.backgroundImage = `url(${iconUrl})`;
                
                topologyPreview.appendChild(nodeElement);
                
                // åˆ›å»ºèŠ‚ç‚¹æ ‡ç­¾
                const label = document.createElement('div');
                label.className = 'node-label';
                label.textContent = nodeId;
                
                // æ ¹æ®èŠ‚ç‚¹ä½ç½®è®¾ç½®æ ‡ç­¾ä½ç½®
                if (index < routeNodes.length / 3) {
                    // å·¦ä¾§èŠ‚ç‚¹ - æ ‡ç­¾åœ¨å·¦ä¾§
                    label.style.left = `${x - 30 - 90}px`;
                    label.style.top = `${y - 15}px`;
                } else if (index > routeNodes.length - Math.ceil(routeNodes.length / 3)) {
                    // å³ä¾§èŠ‚ç‚¹ - æ ‡ç­¾åœ¨å³ä¾§
                    label.style.left = `${x + 30 + 10}px`;
                    label.style.top = `${y - 15}px`;
                } else {
                    // åº•éƒ¨èŠ‚ç‚¹ - æ ‡ç­¾åœ¨ä¸‹æ–¹
                    label.style.left = `${x - 60}px`;
                    label.style.top = `${y + 30 + 15}px`;
                }
                
                // æ™ºèƒ½è°ƒæ•´æ ‡ç­¾ä½ç½®é¿å…é‡å 
                adjustLabelPosition(label, nodeElement);
                
                topologyPreview.appendChild(label);
            });
            
            // é‡ç½®è§†å›¾
            scale = 1;
            offsetX = 0;
            offsetY = 0;
            setViewTransform();
        }
        
        // æ™ºèƒ½è°ƒæ•´æ ‡ç­¾ä½ç½®é¿å…é‡å 
        function adjustLabelPosition(label, nodeElement) {
            // è·å–èŠ‚ç‚¹ä½ç½®
            const nodeRect = nodeElement.getBoundingClientRect();
            const containerRect = topologyPreview.getBoundingClientRect();
            
            // è®¡ç®—èŠ‚ç‚¹ä¸­å¿ƒä½ç½®
            const nodeCenterX = nodeRect.left + nodeRect.width/2 - containerRect.left;
            const nodeCenterY = nodeRect.top + nodeRect.height/2 - containerRect.top;
            
            // è·å–æ ‡ç­¾ä½ç½®
            const labelLeft = parseInt(label.style.left);
            const labelTop = parseInt(label.style.top);
            
            // è®¡ç®—æ ‡ç­¾ä¸­å¿ƒä½ç½®
            const labelCenterX = labelLeft + label.offsetWidth/2;
            const labelCenterY = labelTop + label.offsetHeight/2;
            
            // è®¡ç®—æ ‡ç­¾ä¸èŠ‚ç‚¹çš„è·ç¦»
            const dx = labelCenterX - nodeCenterX;
            const dy = labelCenterY - nodeCenterY;
            const distance = Math.sqrt(dx*dx + dy*dy);
            
            // æœ€å°å®‰å…¨è·ç¦»ï¼ˆèŠ‚ç‚¹åŠå¾„ + æ ‡ç­¾ä¸€åŠé«˜åº¦ï¼‰
            const minDistance = 60;
            
            if (distance < minDistance) {
                // è®¡ç®—éœ€è¦ç§»åŠ¨çš„æ–¹å‘å’Œè·ç¦»
                const moveDistance = minDistance - distance + 10;
                const moveX = (dx / distance) * moveDistance;
                const moveY = (dy / distance) * moveDistance;
                
                // åº”ç”¨æ–°ä½ç½®
                label.style.left = `${labelLeft + moveX}px`;
                label.style.top = `${labelTop + moveY}px`;
            }
        }
        
        // è®¡ç®—å‡µå½¢å¸ƒå±€ä½ç½®ï¼ˆå¼€å£å‘ä¸‹ï¼‰
        function calculateUShapeLayout(nodes, containerWidth, containerHeight) {
            const positions = [];
            const nodeCount = nodes.length;
            
            // å¸ƒå±€å‚æ•°
            const marginX = 100;
            const marginY = 80;
            const availableWidth = containerWidth - 2 * marginX;
            const availableHeight = containerHeight - 2 * marginY;
            
            // è®¡ç®—æ¯è¾¹çš„èŠ‚ç‚¹æ•°
            const leftCount = Math.ceil(nodeCount / 3);
            const bottomCount = nodeCount - 2 * leftCount;
            const rightCount = leftCount;
            
            // è®¡ç®—é—´è·
            const leftSpacing = availableHeight / (leftCount - 1) * 0.85;
            const bottomSpacing = availableWidth / (bottomCount + 1) * 0.85;
            const rightSpacing = availableHeight / (rightCount - 1) * 0.85;
            
            // å‡µå½¢å¸ƒå±€ï¼ˆå¼€å£å‘ä¸‹ï¼‰ï¼š
            // å·¦ä¾§ï¼šä»ä¸Šåˆ°ä¸‹
            // åº•éƒ¨ï¼šä»å·¦åˆ°å³
            // å³ä¾§ï¼šä»ä¸‹åˆ°ä¸Š
            
            for (let i = 0; i < nodeCount; i++) {
                let x, y;
                
                // å·¦ä¾§èŠ‚ç‚¹ (ä»ä¸Šåˆ°ä¸‹)
                if (i < leftCount) {
                    x = marginX;
                    y = marginY + i * leftSpacing;
                }
                // åº•éƒ¨èŠ‚ç‚¹ (ä»å·¦åˆ°å³)
                else if (i < leftCount + bottomCount) {
                    const bottomIndex = i - leftCount;
                    x = marginX + (bottomIndex + 1) * bottomSpacing;
                    y = marginY + availableHeight;
                }
                // å³ä¾§èŠ‚ç‚¹ (ä»ä¸‹åˆ°ä¸Š) - ä¿®æ­£ï¼šä»åº•éƒ¨å¼€å§‹å‘ä¸Šæ’åˆ—
                else {
                    const rightIndex = i - (leftCount + bottomCount);
                    x = marginX + availableWidth;
                    y = marginY + availableHeight - rightIndex * rightSpacing;
                }
                
                positions.push({x, y});
            }
            
            return {
                positions: positions,
                width: availableWidth + 2 * marginX,
                height: availableHeight + 2 * marginY
            };
        }
        
        // è·å–çº¿è·¯ç±»å‹
        function getLineType(ring, start, end) {
            for (const segment of ring.segments) {
                if ((segment.start === start && segment.end === end) || 
                    (segment.start === end && segment.end === start)) {
                    return segment.cableType;
                }
            }
            return 'åˆ©æ—§'; // é»˜è®¤
        }
        
        // è·å–çº¿è·¯è·ç¦»
        function getLineDistance(ring, start, end) {
            for (const segment of ring.segments) {
                if ((segment.start === start && segment.end === end) || 
                    (segment.start === end && segment.end === start)) {
                    return segment.distance;
                }
            }
            return '';
        }
        
        // ç”ŸæˆPPT
        generateBtn.addEventListener('click', generatePPT);
        
        async function generatePPT() {
            if (ringData.length === 0) {
                showStatus('æ²¡æœ‰å¯ç”¨çš„æ•°æ®ç”ŸæˆPPT', 'error');
                return;
            }
            
            // ç¡®ä¿æ‰€æœ‰å›¾æ ‡éƒ½å·²åŠ è½½
            const iconsLoaded = Object.values(iconBase64Data).every(base64 => base64 !== null);
            if (!iconsLoaded) {
                showStatus("å›¾æ ‡èµ„æºå°šæœªå®Œå…¨åŠ è½½ï¼Œè¯·ç¨åå†è¯•", "error");
                return;
            }
            
            try {
                showStatus("æ­£åœ¨ç”ŸæˆPPTï¼Œè¯·ç¨å€™...", "loading");
                
                // åˆ›å»ºPPTå®ä¾‹
                const pptx = new PptxGenJS();
                
                // è®¾ç½®PPTå±æ€§
                pptx.author = "ä¼ è¾“è®¾å¤‡ç»„ç¯æ‹“æ‰‘è‡ªåŠ¨ç”Ÿæˆå·¥å…·";
                pptx.company = "å¾®ä¿¡å…¬ä¼—å·ï¼šè½¯ä»¶å¸®Pro";
                pptx.revision = "1.0";
                pptx.title = "ä¼ è¾“è®¾å¤‡ç»„ç¯æ‹“æ‰‘æ–¹æ¡ˆ";
                pptx.layout = "LAYOUT_16x9";
                
                // ä¸ºæ¯ä¸ªç¯åˆ›å»ºä¸€ä¸ªå¹»ç¯ç‰‡
                for (let i = 0; i < ringData.length; i++) {
                    const ring = ringData[i];
                    const slide = pptx.addSlide();
                    
                    // æ·»åŠ æ ‡é¢˜ï¼ˆå·¦ä¸Šè§’ï¼‰
                    slide.addText(ring.name, {
                        x: 0.5,
                        y: 0.3,
                        w: "90%",
                        h: 0.5,
                        fontSize: 16,
                        bold: true,
                        color: "000000",
                        fontFace: "å®‹ä½“",
                        align: "left"
                    });
                    
                    // åˆ›å»ºèŠ‚ç‚¹å’Œçº¿è·¯
                    const nodes = {};
                    
                    // æ”¶é›†æ‰€æœ‰èŠ‚ç‚¹
                    ring.segments.forEach(segment => {
                        if (segment.start) {
                            nodes[segment.start] = {
                                id: segment.start,
                                type: getNodeType(segment.start, ring),
                                distance: segment.distance
                            };
                        }
                        
                        if (segment.end) {
                            nodes[segment.end] = {
                                id: segment.end,
                                type: getNodeType(segment.end, ring),
                                distance: segment.distance
                            };
                        }
                    });
                    
                    // ä½¿ç”¨è·¯ç”±é¡ºåºæ’åˆ—èŠ‚ç‚¹
                    const routeNodes = ring.routeNodes || Object.keys(nodes);
                    
                    // è®¡ç®—èŠ‚ç‚¹ä½ç½®ï¼ˆPPTä¸­çš„å‡µå½¢å¸ƒå±€ - å¼€å£å‘ä¸‹ï¼‰
                    const layout = calculatePPTUShapeLayout(routeNodes);
                    let positions = layout.positions;
                    const { leftCount, bottomCount, rightCount } = layout;
                    
                    // è®¡ç®—å¸ƒå±€è¾¹ç•Œ
                    let minX = Number.MAX_VALUE, maxX = Number.MIN_VALUE;
                    let minY = Number.MAX_VALUE, maxY = Number.MIN_VALUE;
                    
                    Object.values(positions).forEach(pos => {
                        minX = Math.min(minX, pos.x);
                        maxX = Math.max(maxX, pos.x);
                        minY = Math.min(minY, pos.y);
                        maxY = Math.max(maxY, pos.y);
                    });
                    
                    // ç›®æ ‡åŒºåŸŸä½ç½® (æ ‡é¢˜ä¸‹æ–¹ä¸¤è¡Œä½ç½®)
                    const targetStartX = 1.0;
                    const targetStartY = 1.3; // æ ‡é¢˜ä¸‹æ–¹ä¸¤è¡Œ
                    
                    // è®¡ç®—å±…ä¸­åç§»é‡
                    const topologyWidth = maxX - minX;
                    const topologyHeight = maxY - minY;
                    const slideWidth = 10; // PPTé¡µé¢å®½åº¦10è‹±å¯¸
                    const centerOffsetX = (slideWidth - topologyWidth * 0.6) / 2;
                    
                    // å‡†å¤‡ç»„åˆå¯¹è±¡
                    const slideObjects = [];
                    
                    // ç»˜åˆ¶çº¿è·¯ - æŒ‰ç…§è·¯ç”±é¡ºåº
                    for (let j = 0; j < routeNodes.length - 1; j++) {
                        const startNode = routeNodes[j];
                        const endNode = routeNodes[j+1];
                        
                        if (!positions[startNode] || !positions[endNode]) continue;
                        
                        // åº”ç”¨ç¼©æ”¾å’Œå¹³ç§»ï¼ˆæ•´ä½“ç¼©å°40%ï¼‰
                        let x1 = ((positions[startNode].x - minX) * 0.6) + centerOffsetX;
                        let y1 = ((positions[startNode].y - minY) * 0.6) + targetStartY;
                        let x2 = ((positions[endNode].x - minX) * 0.6) + centerOffsetX;
                        let y2 = ((positions[endNode].y - minY) * 0.6) + targetStartY;
                        
                        // æ·»åŠ çº¿è·¯
                        const lineType = getLineType(ring, startNode, endNode);
                        const lineWidth = 0.03; // 0.03è‹±å¯¸ â‰ˆ 0.76æ¯«ç±³
                        const lineColor = lineType === 'æ–°å»º' ? "F44336" : "4CAF50";
                        
                        // åˆ¤æ–­çº¿è·¯æ–¹å‘ï¼ˆæ°´å¹³æˆ–å‚ç›´ï¼‰
                        if (Math.abs(y1 - y2) < 0.001) {
                            // æ°´å¹³çº¿
                            slide.addShape(pptx.ShapeType.line, {
                                x: x1,
                                y: y1,
                                w: x2 - x1,
                                h: 0,
                                line: {
                                    color: lineColor,
                                    width: lineWidth,
                                    dashType: "solid"
                                }
                            });
                        } else if (Math.abs(x1 - x2) < 0.001) {
                            // å‚ç›´çº¿
                            slide.addShape(pptx.ShapeType.line, {
                                x: x1,
                                y: y1,
                                w: 0,
                                h: y2 - y1,
                                line: {
                                    color: lineColor,
                                    width: lineWidth,
                                    dashType: "solid"
                                }
                            });
                        } else {
                            // æ–œçº¿ï¼ˆåº”é¿å…ï¼‰
                            slide.addShape(pptx.ShapeType.line, {
                                x: x1,
                                y: y1,
                                w: x2 - x1,
                                h: y2 - y1,
                                line: {
                                    color: lineColor,
                                    width: lineWidth,
                                    dashType: "solid"
                                }
                            });
                        }
                        
                        // æ·»åŠ è·ç¦»æ ‡ç­¾
                        const midX = (x1 + x2) / 2;
                        const midY = (y1 + y2) / 2;
                        const distance = getLineDistance(ring, startNode, endNode) || '';
                        
                        if (distance) {
                            slide.addText(distance, {
                                x: midX - 0.5,
                                y: midY - 0.15,
                                w: 1.0,
                                h: 0.3,
                                fontSize: 10,
                                color: "000000",
                                fill: { color: "FFFFFF", transparency: 100 }, // èƒŒæ™¯å…¨é€æ˜
                                align: "center",
                                valign: "middle"
                            });
                        }
                    }
                    
                    // ç»˜åˆ¶èŠ‚ç‚¹
                    for (let j = 0; j < routeNodes.length; j++) {
                        const nodeId = routeNodes[j];
                        if (!positions[nodeId]) continue;
                        
                        // åº”ç”¨ç¼©æ”¾å’Œå¹³ç§»ï¼ˆæ•´ä½“ç¼©å°40%ï¼‰
                        const x = ((positions[nodeId].x - minX) * 0.6) + centerOffsetX;
                        const y = ((positions[nodeId].y - minY) * 0.6) + targetStartY;
                        
                        const node = nodes[nodeId] || {
                            id: nodeId,
                            type: getNodeType(nodeId, ring)
                        };
                        
                        // è·å–èŠ‚ç‚¹å¯¹åº”çš„Base64æ•°æ®
                        const base64Data = iconBase64Data[node.type] || iconBase64Data['åŸæœ‰è®¾å¤‡'];
                        
                        // æ·»åŠ èŠ‚ç‚¹å›¾ç‰‡ï¼ˆå›¾æ ‡ç¼©å°50%ï¼‰
                        slide.addImage({
                            data: base64Data,
                            x: x - 0.15,  // å›¾æ ‡å¤§å°0.3è‹±å¯¸
                            y: y - 0.15,
                            w: 0.3,
                            h: 0.3
                        });
                        
                        // æ·»åŠ èŠ‚ç‚¹æ ‡ç­¾ï¼ˆæ–‡å­—é¢œè‰²ä¸ºé»‘è‰²ï¼‰
                        let labelX, labelY, align, valign, w, h;
                        w = 1.2;
                        h = 0.4;
                        align = "center";
                        valign = "middle";
                        
                        // æ ¹æ®èŠ‚ç‚¹ä½ç½®è°ƒæ•´æ ‡ç­¾ä½ç½®
                        if (j < leftCount) {
                            // å·¦ä¾§èŠ‚ç‚¹ - æ ‡ç­¾åœ¨å·¦ä¾§
                            labelX = x - 0.15 - w;
                            labelY = y - 0.15;
                            align = "right";
                        } else if (j < leftCount + bottomCount) {
                            // åº•éƒ¨èŠ‚ç‚¹ - æ ‡ç­¾åœ¨ä¸‹æ–¹
                            labelX = x - w/2;
                            labelY = y + 0.15;
                            valign = "top";
                        } else {
                            // å³ä¾§èŠ‚ç‚¹ - æ ‡ç­¾åœ¨å³ä¾§
                            labelX = x + 0.15;
                            labelY = y - 0.15;
                            align = "left";
                        }
                        
                        slide.addText(nodeId, {
                            x: labelX,
                            y: labelY,
                            w: w,
                            h: h,
                            fontSize: 10,
                            bold: true,
                            color: "000000",
                            align: align,
                            valign: valign,
                            autoFit: true,
                            wordWrap: true
                        });
                    }
                    
                    // æ·»åŠ å›¾ä¾‹è¯´æ˜ï¼ˆå·¦ä¸‹è§’ï¼‰
                    const legendItems = [
                        { type: "æœºæˆ¿", image: iconBase64Data['æœºæˆ¿'] },
                        { type: "åŸæœ‰è®¾å¤‡", image: iconBase64Data['åŸæœ‰è®¾å¤‡'] },
                        { type: "æ–°å¢è®¾å¤‡", image: iconBase64Data['æ–°å¢è®¾å¤‡'] },
                        { type: "è·³çº¤ç‚¹", image: iconBase64Data['è·³çº¤ç‚¹'] },
                        { type: "åŸæœ‰å…‰ç¼†", color: "4CAF50", isLine: true },
                        { type: "æ–°å»ºå…‰ç¼†", color: "F44336", isLine: true }
                    ];
                    
                    // å›¾ä¾‹ä½ç½®ï¼ˆå·¦ä¸‹è§’ï¼‰
                    const legendStartX = 0.5;
                    const legendY = 5.0; // è°ƒæ•´åˆ°é¡µé¢å†…éƒ¨
                    const legendItemWidth = 1.2;
                    const legendSpacing = 0.2;
                    
                    // æ·»åŠ å›¾ä¾‹é¡¹
                    for (let k = 0; k < legendItems.length; k++) {
                        const item = legendItems[k];
                        const xPos = legendStartX + k * (legendItemWidth + legendSpacing);
                        
                        if (item.image) {
                            // èŠ‚ç‚¹å›¾ä¾‹ - ä½¿ç”¨å›¾ç‰‡
                            slide.addImage({
                                data: item.image,
                                x: xPos + legendItemWidth/2 - 0.15,
                                y: legendY,
                                w: 0.3,
                                h: 0.3,
                                align: 'center'
                            });
                            
                            // å›¾ä¾‹æ–‡å­—
                            slide.addText(item.type, {
                                x: xPos,
                                y: legendY + 0.35,
                                w: legendItemWidth,
                                h: 0.2,
                                fontSize: 10,
                                color: "000000",
                                align: "center"
                            });
                        } else if (item.isLine) {
                            // çº¿ç¼†å›¾ä¾‹
                            slide.addShape(pptx.ShapeType.line, {
                                x: xPos + 0.2,
                                y: legendY + 0.15,
                                w: legendItemWidth - 0.4,
                                h: 0,
                                line: {
                                    color: item.color,
                                    width: 0.03
                                }
                            });
                            
                            // å›¾ä¾‹æ–‡å­—
                            slide.addText(item.type, {
                                x: xPos,
                                y: legendY + 0.35,
                                w: legendItemWidth,
                                h: 0.2,
                                fontSize: 10,
                                color: "000000",
                                align: "center"
                            });
                        }
                    }
                }
                
                // ä¿å­˜PPT
                pptx.writeFile({fileName: `ä¼ è¾“è®¾å¤‡ç»„ç¯æ‹“æ‰‘æ–¹æ¡ˆ${new Date().toISOString().slice(0, 10)}.pptx`})
                    .then(() => {
                        showStatus("PPTæ–‡ä»¶ç”ŸæˆæˆåŠŸå¹¶å·²å¼€å§‹ä¸‹è½½ï¼", "success");
                    })
                    .catch(error => {
                        console.error('Error generating PPT:', error);
                        showStatus("ç”ŸæˆPPTæ—¶å‡ºé”™: " + error.message, "error");
                    });
                
            } catch (error) {
                console.error('Error in PPT generation:', error);
                showStatus("ç”ŸæˆPPTæ—¶å‡ºé”™: " + error.message, "error");
            }
        }
        
        // è®¡ç®—PPTä¸­çš„å‡µå½¢å¸ƒå±€ä½ç½®ï¼ˆå¼€å£å‘ä¸‹ï¼‰
        function calculatePPTUShapeLayout(nodes) {
            const positions = {};
            const nodeCount = nodes.length;
            
            // è®¡ç®—æ¯è¾¹çš„èŠ‚ç‚¹æ•°
            const leftCount = Math.ceil(nodeCount / 3);
            const bottomCount = nodeCount - 2 * leftCount;
            const rightCount = leftCount;
            
            // è®¡ç®—èŠ‚ç‚¹é—´è·ï¼ˆ2-5å˜ç±³ï¼Œè½¬æ¢ä¸ºè‹±å¯¸ï¼‰
            const minSpacing = 2 * 0.3937; // 2å˜ç±³è½¬è‹±å¯¸
            const maxSpacing = 5 * 0.3937; // 5å˜ç±³è½¬è‹±å¯¸
            
            // åŠ¨æ€è®¡ç®—å‚ç›´é—´è·
            let verticalSpacing = maxSpacing;
            if (leftCount > 1) {
                verticalSpacing = Math.max(minSpacing, Math.min(maxSpacing, maxSpacing - (leftCount - 1) * 0.2));
            }
            
            // åŠ¨æ€è®¡ç®—æ°´å¹³é—´è·
            let horizontalSpacing = maxSpacing;
            if (bottomCount > 0) {
                horizontalSpacing = Math.max(minSpacing, Math.min(maxSpacing, maxSpacing - (bottomCount - 1) * 0.2));
            }
            
            // è®¾ç½®åŸºç‚¹ (0,0)
            const baseX = 0;
            const baseY = 0;
            
            // å·¦ä¾§èŠ‚ç‚¹ï¼ˆä»ä¸Šåˆ°ä¸‹ï¼‰
            for (let i = 0; i < leftCount; i++) {
                const nodeId = nodes[i];
                positions[nodeId] = {
                    x: baseX,
                    y: baseY + i * verticalSpacing
                };
            }
            
            // åº•éƒ¨èŠ‚ç‚¹ï¼ˆä»å·¦åˆ°å³ï¼‰
            for (let i = 0; i < bottomCount; i++) {
                const nodeId = nodes[leftCount + i];
                positions[nodeId] = {
                    x: baseX + (i + 1) * horizontalSpacing,
                    y: baseY + (leftCount - 1) * verticalSpacing
                };
            }
            
            // å³ä¾§èŠ‚ç‚¹ï¼ˆä»ä¸‹åˆ°ä¸Šï¼‰ - ä¿®æ­£ï¼šä»åº•éƒ¨å¼€å§‹å‘ä¸Šæ’åˆ—
            for (let i = 0; i < rightCount; i++) {
                const nodeId = nodes[leftCount + bottomCount + i];
                positions[nodeId] = {
                    x: baseX + (bottomCount + 1) * horizontalSpacing,
                    y: baseY + (leftCount - 1) * verticalSpacing - i * verticalSpacing
                };
            }
            
            return {
                positions: positions,
                leftCount: leftCount,
                bottomCount: bottomCount,
                rightCount: rightCount
            };
        }
        
        // ç¤ºä¾‹æ–‡ä»¶ä¸‹è½½
        sampleBtn.addEventListener('click', () => {
            // åˆ›å»ºç¤ºä¾‹æ•°æ®
            const sampleData = [
                ["åºå·", "æ¥å…¥ç¯", "å¿åŒº", "èµ·ç‚¹", "ç»ˆç‚¹", "å…‰ç¼†å±æ€§", "å…‰ç¼†èŠ¯æ•°", "å…‰ç¼†è·ç¦»", "ç»¼åˆæœºæˆ¿1", "ç»¼åˆæœºæˆ¿2", "ç¯è·¯ç”±", "æ–°å¢è®¾å¤‡ç«™ç‚¹", "åŸæœ‰è®¾å¤‡ç«™ç‚¹"],
                [1, "XXåŒºD-RAN10GEæ¥å…¥ç¯01", "XXåŒº", "æœºæˆ¿1", "åŸºç«™1", "åˆ©æ—§", 48, "0.5km", "æœºæˆ¿1", "æœºæˆ¿2", "æœºæˆ¿1-åŸºç«™1-åŸºç«™2-åŸºç«™3-åŸºç«™4-åŸºç«™5-æœºæˆ¿2", "", "åŸºç«™1"],
                [2, "", "XXåŒº", "åŸºç«™1", "åŸºç«™2", "æ–°å»º", 24, "1.2km", "", "", "", "åŸºç«™2", "åŸºç«™3"],
                [3, "", "XXåŒº", "åŸºç«™2", "åŸºç«™3", "æ–°å»º", 24, "2.2km", "", "", "", "", ""],
                [4, "", "XXåŒº", "åŸºç«™3", "åŸºç«™4", "æ–°å»º", 24, "5.3km", "", "", "", "åŸºç«™5", "åŸºç«™4"],
                [5, "", "XXåŒº", "åŸºç«™4", "æœºæˆ¿2", "åˆ©æ—§", 96, "1.1km", "", "", "", "", ""],
                [],
                [6, "XXå¿D-RAN10GEæ¥å…¥ç¯02", "XXå¿", "æœºæˆ¿A", "åŸºç«™A1", "åˆ©æ—§", 48, "0.7km", "æœºæˆ¿A", "æœºæˆ¿B", "æœºæˆ¿A-åŸºç«™A1-åŸºç«™A2-åŸºç«™A3-æœºæˆ¿B", "", "åŸºç«™A1"],
                [7, "", "XXå¿", "åŸºç«™A1", "åŸºç«™A2", "æ–°å»º", 24, "1.5km", "", "", "", "åŸºç«™A2", "åŸºç«™A3"],
                [8, "", "XXå¿", "åŸºç«™A2", "åŸºç«™A3", "æ–°å»º", 24, "2.8km", "", "", "", "", ""],
                [9, "", "XXå¿", "åŸºç«™A3", "æœºæˆ¿B", "åˆ©æ—§", 96, "0.9km", "", "", "", "", ""]
            ];
            
            // åˆ›å»ºå·¥ä½œç°¿
            const wb = XLSX.utils.book_new();
            const ws = XLSX.utils.aoa_to_sheet(sampleData);
            XLSX.utils.book_append_sheet(wb, ws, "Sheet1");
            
            // ç”Ÿæˆæ–‡ä»¶å¹¶ä¸‹è½½
            XLSX.writeFile(wb, "ä¼ è¾“è®¾å¤‡ç»„ç¯è·³çº¤è¡¨ç¤ºä¾‹.xlsx");
            
            showStatus("ç¤ºä¾‹æ–‡ä»¶å·²ä¸‹è½½ï¼", "success");
        });
        
        // æ˜¾ç¤ºçŠ¶æ€æ¶ˆæ¯
        function showStatus(message, type) {
            statusMessage.textContent = message;
            statusMessage.className = "status " + type;
            statusMessage.style.display = "block";
            statusMessage.style.opacity = "1";
            
            if (type !== "loading") {
                // 3ç§’åè‡ªåŠ¨éšè—
                setTimeout(() => {
                    statusMessage.style.opacity = "0";
                    setTimeout(() => {
                        statusMessage.style.display = "none";
                    }, 500);
                }, 3000);
            }
        }
    </script>
</body>
</html>